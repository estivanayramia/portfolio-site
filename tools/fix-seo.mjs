import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, '..');

// Configuration
const siteUrl = 'https://www.estivanayramia.com';
const excludeFiles = ['index.html', '404.html'];
const localeDirs = ['es', 'ar'];
const GENERATE_REDIRECTS = process.argv.includes('--redirects');
const UPDATE_HTML = process.argv.includes('--html');
const UPDATE_SITEMAP = process.argv.includes('--sitemap');
const UPDATE_ALL = process.argv.includes('--all');

// CLI flags
if (!GENERATE_REDIRECTS && !UPDATE_HTML && !UPDATE_SITEMAP && !UPDATE_ALL) {
    console.log('Usage: node tools/fix-seo.mjs [flags]');
    console.log('Flags:');
    console.log('  --redirects  Generate _redirects');
    console.log('  --html       Update HTML files (links, canonical, meta)');
    console.log('  --sitemap    Update sitemap.xml');
    console.log('  --all        Run all updates');
    process.exit(0);
}

// 1. Inventory Routes (EN-aware)
function getHtmlFiles(dir, relativePath = '') {
    let results = [];
    const list = fs.readdirSync(dir);
    list.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        if (stat && stat.isDirectory()) {
            if (localeDirs.includes(file)) {
                // Check for index.html in locale dir
                if (fs.existsSync(path.join(filePath, 'index.html'))) {
                    results.push(path.join(relativePath, file, 'index.html'));
                }
            } else if (file === 'EN') {
                // Recursively scan EN for English pages
                const enFiles = getHtmlFiles(filePath, 'EN');
                results.push(...enFiles);
            } else if (relativePath === 'EN') {
                // Recurse into subdirs like projects/
                const subFiles = getHtmlFiles(filePath, path.join(relativePath, file));
                results.push(...subFiles);
            }
        } else {
            if (file.endsWith('.html')) {
                results.push(path.join(relativePath, file));
            }
        }
    });
    return results;
}

const allHtmlFiles = getHtmlFiles(rootDir);
const indexableFiles = allHtmlFiles.filter(f => !excludeFiles.includes(f) && !localeDirs.some(d => f.startsWith(d + path.sep)));
const localeFiles = allHtmlFiles.filter(f => localeDirs.some(d => f.startsWith(d + path.sep)));

// Map EN files to canonical routes
function mapToCanonicalRoute(filePath) {
    const normalized = filePath.replace(/\\/g, '/'); // Normalize to forward slashes
    if (normalized.startsWith('EN/')) {
        const enPath = normalized.replace('EN/', '');
        if (enPath === 'index.html') return '/';
        if (enPath.endsWith('/index.html')) return '/' + enPath.replace('/index.html', '/');
        return '/' + enPath.replace('.html', '');
    }
    // For locales, keep as is
    if (normalized.startsWith('es/') || normalized.startsWith('ar/')) {
        return '/' + normalized.replace('.html', '');
    }
    return '/' + normalized.replace('.html', '');
}

console.log('Indexable Files:', indexableFiles);
console.log('Locale Files:', localeFiles);

// 2. Fix _redirects
function generateRedirects() {
    let content = `# Cloudflare Pages Redirects & Rewrites
# Generated by tools/fix-seo.mjs

# 1. Canonical Redirects (301) - Enforce clean URLs
/index.html                  /                            301!
/es/index.html               /es/                         301!
/ar/index.html               /ar/                         301!

`;

    indexableFiles.forEach(file => {
        const slug = file.replace('.html', '');
        content += `/${file}                   /${slug}                       301!\n`;
    });

    content += `
# 2. Rewrites (200) - Serve content for clean URLs
`;

    // Locale rewrites
    content += `/es/                         /es/index.html               200\n`;
    content += `/ar/                         /ar/index.html               200\n`;

    indexableFiles.forEach(file => {
        const canonical = mapToCanonicalRoute(file);
        const normalizedFile = file.replace(/\\/g, '/');
        content += `${canonical}                       /${normalizedFile}                       200\n`;
    });

    // 404 Fallback (optional but good practice)
    content += `
# 404 Fallback
/404.html                    404
`;

    fs.writeFileSync(path.join(rootDir, '_redirects'), content);
    console.log('Generated _redirects');
}

// 3 & 4. Update HTML Content (Links, Canonical, Meta, JSON-LD)
function updateHtmlContent() {
    const filesToProcess = [...indexableFiles, ...localeFiles];

    filesToProcess.forEach(relativePath => {
        const filePath = path.join(rootDir, relativePath);
        let content = fs.readFileSync(filePath, 'utf8');
        let originalContent = content;

        // Determine clean URL for this page
        let cleanPath = mapToCanonicalRoute(relativePath);
        if (cleanPath === '/') cleanPath = '';

        const fullUrl = siteUrl + cleanPath;

        // A. Update Internal Links (strip trailing .html)
        // Regex to find internal href values ending with .html
        content = content.replace(/href=(["'])([^"']+)\.html\1/g, (match, quote, url) => {
            // Don't touch external links
            if (url.startsWith('http')) return match;
            // Don't touch index.html if it's meant to be root (usually /index.html -> /)
            if (url === '/index' || url === 'index') return `href=${quote}/${quote}`;
            if (url.endsWith('/index')) return `href=${quote}${url.replace('/index', '/')}${quote}`;
            
            return `href=${quote}${url}${quote}`;
        });

        // B. Update data-print-url
        content = content.replace(/data-print-url=(["'])([^"']+)\.html\1/g, (match, quote, url) => {
             return `data-print-url=${quote}${url}${quote}`;
        });

        // C. Update Canonical
        // <link rel="canonical" href="...">
        const canonicalRegex = /<link\s+rel=["']canonical["']\s+href=["']([^"']+)["']\s*\/?>/i;
        if (canonicalRegex.test(content)) {
            content = content.replace(canonicalRegex, `<link rel="canonical" href="${fullUrl}">`);
        } else {
            // Insert if missing (in head)
            content = content.replace('</head>', `  <link rel="canonical" href="${fullUrl}">\n</head>`);
        }

        // D. Update OG URL
        const ogUrlRegex = /<meta\s+property=["']og:url["']\s+content=["']([^"']+)["']\s*\/?>/i;
        if (ogUrlRegex.test(content)) {
            content = content.replace(ogUrlRegex, `<meta property="og:url" content="${fullUrl}">`);
        }

        // E. Update Twitter URL
        const twitterUrlRegex = /<meta\s+name=["']twitter:url["']\s+content=["']([^"']+)["']\s*\/?>/i;
        if (twitterUrlRegex.test(content)) {
            content = content.replace(twitterUrlRegex, `<meta name="twitter:url" content="${fullUrl}">`);
        }

        // F. Update JSON-LD "url"
        // Look for JSON-LD url values that end with .html for the known domain
        // We'll use a specific regex for the known domain to be safe
        const jsonLdUrlRegex = /"url":\s*"https:\/\/www\.estivanayramia\.com\/([^"]+)\.html"/g;
        content = content.replace(jsonLdUrlRegex, (match, slug) => {
            if (slug === 'index') return `"url": "${siteUrl}/"`;
            return `"url": "${siteUrl}/${slug}"`;
        });

        if (content !== originalContent) {
            fs.writeFileSync(filePath, content);
            console.log(`Updated ${relativePath}`);
        }
    });
}

// 5. Update sitemap.xml
function updateSitemap() {
    let sitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
`;

    const urls = [];
    
    // Root
    urls.push(siteUrl + '/');

    // Locales
    localeDirs.forEach(dir => {
        urls.push(siteUrl + '/' + dir + '/');
    });

    // Pages from indexableFiles, mapped to canonical
    indexableFiles.forEach(file => {
        const canonical = mapToCanonicalRoute(file);
        urls.push(siteUrl + canonical);
    });

    urls.forEach(url => {
        sitemap += `  <url>
    <loc>${url}</loc>
  </url>
`;
    });

    sitemap += `</urlset>`;
    
    fs.writeFileSync(path.join(rootDir, 'sitemap.xml'), sitemap);
    console.log('Updated sitemap.xml');
}

// Run
if (GENERATE_REDIRECTS || UPDATE_ALL) {
    generateRedirects();
}

if (UPDATE_HTML || UPDATE_ALL) {
    updateHtmlContent();
}

if (UPDATE_SITEMAP || UPDATE_ALL) {
    updateSitemap();
}
